------------------- Библиотека служебных скриптов для OGSM 2.x ----------------

---------------------- Copyright 2007-2008 xStream & DEXXX --------------------

local npc_spawner={}
local timers={}
local g_timers={}
local markers={}
local x_objs={}
local timer_trigger=nil
wthr = level.get_weather()
local wfx1 = "p_surge_day_"..tostring(level.get_time_hours())
local wfx2 = "surge_day_"..tostring(level.get_time_hours())

local indoor_levels = {
	l12_stancia = true,
	l12_stancia_2 = true,
	jupiter_underground = true,
	l03u_agr_underground = true,
	l04u_labx18 = true,
	l08u_brainlab = true,
	l12u_sarcofag = true,
	l12u_control_monolith = true,
	warlab = true,
	labx8 = true,
	cs_agroprom_underground = true,
	l10u_bunker = true,
	av_peshera = true,
	peshera = true
}

-- Переменные для типсов
pda_news = xr_sound.get_safe_sound_object([[device\pda\pda_news]])
pda_tips = xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
pda_task = xr_sound.get_safe_sound_object([[device\pda\pda_objective]])

tips_icons = {
	default = { 82, 282},
	trader = { 332, 893},
	dolg = { 0, 658},
	freedom = { 0, 658},
	ecolog = { 498, 0},
	arena = { 332, 141},
	stalker = { 0, 658},
	krot = { 332, 47},
	barman = { 332, 235},
	wolf = { 332, 940},
	o_soznanie = { 498, 893},
	monolith = { 0, 658},
	saharov = { 332, 470},
	prizrak = { 0, 658},
	killer = { 0, 658},
	death = { 0, 752}
}


-- Лог данных
local bufferedmessages={}
	function mylog(msg)
		if msg==nil then
			return
		end
		if db and db.actor then
		if bufferedmessages then
			for k,v in ipairs(bufferedmessages) do
				db.actor:give_game_news(v, "ui\\ui_iconsTotal", Frect():set(0,658,83,47), 0, 15000)
			end
			bufferedmessages=nil
		end
			db.actor:give_game_news(msg, "ui\\ui_iconsTotal", Frect():set(0,658,83,47), 0, 15000)
		else
		if bufferedmessages then
			table.insert(bufferedmessages,msg)
		end
	end

	if get_console() then
--	get_console():execute("load "..msg)
-- get_console():execute("flush")
	end
end


-- Показ типса
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if news_text==nil then return end
	if header==nil then header=game.translate_string("st_tip") end
	if timeout == nil then timeout = 0 end
	if showtime == nil then showtime = 5 end
	
	local player
	if sound=="news" then
		player=pda_news
	elseif sound=="task" then
		player=pda_task
	else
		player=pda_tips
	end
	
	--' Играем дефолтный звук
	player:play(db.actor, timeout, sound_object.s2d)
	
	if sender == nil then
		sender = "default"
	end
	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]
	
	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)
	return true
end


-- Старт таймера в реальном времени
function start_timer(name,delay,action)
	if not delay then
		return false
	end
	
	if not action then
		action = ""
	end

	local time = game.time() --time in seconds since 1970
	local a=1
	while db.storage[db.actor:id()].pstor["rt"..a] do
		a=a+1
		if a>100 then
			return false
		end
	end

	save_variable("rt"..a, name)
	save_variable("rt"..a.."d", time+delay*10000)
	save_variable("rt"..a.."p", action)
	
	return true
end


-- Старт таймера в игровом времени
function g_start_timer(name,delay_d,delay_h,delay_m,action)
	if delay_d==nil or delay_h==nil or delay_m==nil then
		return false
	end
	
	if action==nil then
		action = ""
	end
	
	local time = game.time() --time in seconds since 1970
	local a=1
	
	while db.storage[db.actor:id()].pstor["gt"..a] do
		a=a+1
		
		if a>100 then
			return false
		end
	end

	save_variable("gt"..a, name)
	save_variable("gt"..a.."d", time+delay_d*24*60*60*1000+delay_h*60*60*1000+delay_m*60*1000)

	save_variable("gt"..a.."p", action)

	return true
end


-- Проверка таймеров, использует 3 следующие за ним функции для выбора действия
function check_timers()
	local tmp
	for a=1,100,1 do
		tmp=load_variable("rt"..a,nil)
		if tmp~=nil then
			__timer_found(a)
		end
	end
	
	for a=1,100,1 do
		tmp=load_variable("gt"..a,nil)
		if tmp~=nil then
			__g_timer_found(a)
		end
	end
end

function __timer_found(idx)
	local time = game.time() --time in seconds since 1970
	local name,params
	if load_variable("rt"..idx.."d", nil)<=time then
		name=load_variable("rt"..idx, nil)
		params=load_variable("rt"..idx.."p", nil)
		del_variable("rt"..idx)
		del_variable("rt"..idx.."d")
		del_variable("rt"..idx.."p")
		__do_timer_action(name,params)
		return true
	end
	return false
end

function __g_timer_found(idx)
	local gtime = game.time() --time in seconds since 1970

	local name,params,grib
	grib=load_variable("gt"..idx, nil)
	
	if grib=="kil" and has_alife_info("eat_grib") then
		db.actor:disable_info_portion("eat_grib")
		del_variable("gt"..idx)
		del_variable("gt"..idx.."d")
		del_variable("gt"..idx.."p")
		
		if not has_alife_info("no_poison") then
			g_start_timer("kil",0,0,15)
			swamp_old_dialog.show_static2()
		else
			db.actor:give_info_portion("eat_grib2")
		end
		
		return true
	end
	
	if load_variable("gt"..idx.."d", nil)<=gtime then
		name=load_variable("gt"..idx, nil)
		params=load_variable("gt"..idx.."p", nil)
		del_variable("gt"..idx)
		del_variable("gt"..idx.."d")
		del_variable("gt"..idx.."p")
		__do_timer_action(name,params)
		return true
	end
	
	return false
end

function __do_timer_action(select_string,params_string)
	local a
	
	if select_string=="slp" then
		sleep_manager.test_for_need_sleep()
	end
	
	if select_string=="nrg" then
		sleep_manager.test_for_need_sleep_nrg(params_string)
	end
	
	if select_string=="mtr" then
		sleep_manager.test_for_need_sleep_matras(params_string)
	end
	
	if select_string=="men" then
		del_variable("smn")
	end
	
	if select_string=="rfx" then
		ogsm_debug.radar_fix()
	end
	
	if select_string=="otf" then
		a = level.object_by_id(tonumber(params_string))
		if a ~= nil then a:set_condition((math.random(25)+40)/100) end
	end
	
	if select_string=="rsp" then
		ogsm_respawn.level_spawn()
		g_start_timer("rsp",0, vars.t_spawn+math.random(-1,1), 0)
	end
	
	if select_string=="pel" then
		if has_alife_info("start_peleng") and not has_alife_info("end_peleng") then
			local text = "Пеленгация завершена. Обнаружен неопознанный сигнал. Информация отправлена для дешифровки, подождите результатов."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("end_peleng")
			g_start_timer("sob",0, 0, 8)
		end
	end
	
	if select_string=="sob" then
		if has_alife_info("end_peleng") and not has_alife_info("generators_message_doctor_1") then
			local text = "Стрелок, пеленгатор засёк сигнал, идущий от КПК. Возможно, это сигнал от курьера тёмных. В районе антенн обнаружено неизвестное излучение, впрочем, не опасное для людей. Иди к месту, обозначенному меткой. Доктор."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("generators_message_doctor_1")
			local obj = alife():object( "generators_mess_doc_2" )
			if obj then
				level.map_add_object_spot_ser(obj.id, "find_item_location", "Неизвестный КПК")
			end
		end
	end
	
	if select_string=="md2" then
		if has_alife_info("message_doctor_2") and not has_alife_info("generators_message_doctor_2") then
			local text = "Слушай внимательно, Стрелок. Установка, генерирующая излучение, вероятно находится в Варлабе, подземной военной лаборатории. Вход - неподалёку. Необходимо отключить питание всех антенн, тогда, возможно, можно надеяться на хороший исход нашего дела. Будь осторожен. Доктор."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("generators_message_doctor_2")
		end
	end
	
	if select_string=="ggw" then
		if has_alife_info("sixth_talking_doctor") and not has_alife_info("goto_doc3") then
			local text = "Стрелок, слышишь меня? Спешу тебя обрадовать: у меня всё готово в лучшем виде. Приходи скорее. Доктор."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("goto_doc3")
		end
	end
	
	if select_string=="hel" then
		local text = "Герман - Стрелку. Я договорился с военными, хотя это было нелегко... Они послали вертушку к месту падения беспилотника. Вернёшься - зайди в бункер, там поговорим."
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
		db.actor:give_info_portion("take_message_german")
		amk.g_start_timer("he2",0, 0, 1)
	end
	
	if select_string=="he2" then
		db.actor:give_info_portion("heli_start")
	end
	
	if select_string=="mg1" then
		if has_alife_info("give_jammer_german") and not has_alife_info("take_message_strelok") then
			local text = "Стрелок. У монолитовцев всегда существовали списки членов группировки. Сейчас остатки монолитовцев обосновались в Восточной Припяти и если списки членов не уничтожены, они могут быть только там. Удачи тебе, Стрелок. Профессор Герман."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("take_message_strelok")
		end
	end
	
	if select_string=="mg2" then
		if has_alife_info("technik_talk") and not has_alife_info("take_message2_german") then
			local text = "Стрелок. Мы засекли Харона. Его КПК защищён от обнаружения другими сталкерами, но вместе с сообщением я закачал тебе код, при помощи которого ты сможешь найти Харона. Сигнал идёт из северо-западной части В. Припяти, ищи его там. Профессор Герман."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("take_message2_german")
		end
	end
	
	if select_string=="mg3" then
		if has_alife_info("find_haron") and not has_alife_info("take_haron_message") then
			local text = "Стрелок. На твоё счастье, вертушка с военными возвращалась с задания, с медиком на борту. Жди, они приземлятся в твоём квадрате. Профессор Герман."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("take_haron_message")
		end
	end
	
	if select_string=="mg4" then
		local sobj = alife():object("pripyat_rechport_inventory_box_01")
		if sobj then
			local obj = level.object_by_id(sobj.id)
			if obj then
				spawn_item_in_invenn("raport", obj)
			end
		end
	end
	
	if select_string=="he3" then
		db.actor:give_info_portion("prip_heli_start")
	end
	
	if select_string=="stt" then
		db.actor:disable_info_portion("remesov_first_dialog")
	end
	
	if select_string=="zv1" then
		if has_alife_info("going_complete") and not has_alife_info("take_zver_message") then
			local text = "Стрелок, не подходи близко, а то и тебя аномалия затянет. Аккумулятор моего КПК почти разряжен, связаться ни с кем не могу. Пособи, сходи к Ною, это здесь неподалёку. Скажи, мол, так и сяк, Зверь в аномалию попал. Заранее благодарю. Поторопись, Стрелок."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("take_zver_message")
		end
	end
	
	if select_string=="noa" then
		local text = "Стрелок, с документами разобрался. Загляни, есть дело. Ной."
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
		db.actor:give_info_portion("give_message_noah")
	end
	
	if select_string=="po1" or select_string=="po2" then
		get_hud():RemoveCustomStatic("static_poison_gas_on")
	end
	
	if select_string=="po3" then
		db.actor:give_info_portion("get_message_doctor")
	end
	
	if select_string=="kil" then
		db.actor:kill(db.actor)
	end
	
	if select_string=="kl" then
		if level.name()=="puzir" and has_alife_info("kolobok_death") and (not has_alife_info("klyk_first_message")) then
			local text = "Сигнал радиомаяка:".."\\nСтрелок! Иди на сигнал маячка, там найдёшь инфу от меня. Маячок обязательно забери. Клык."
			news_manager.send_tip(db.actor, text, nil, nil, 30000)
			db.actor:give_info_portion("klyk_first_message")
			local sobj = alife():object("puzir_inventory_box_02")
			if sobj and has_alife_info("kolobok_death") then
				local obj = level.object_by_id(sobj.id)
				if obj then
					spawn_item_in_inven("radiophone", obj)
					spawn_item_in_inven("zapiska_klyk2", obj)
					for ammo=1,25 do
						spawn_item_in_inven("ammo_9x19_pbp", obj)
					end
					level.map_add_object_spot_ser(sobj.id, "find_item_location", "Радиомаяк")
				end
			end
		end
	end
	
	if select_string=="akk" then
		local text = "Стрелок, заходи, всё готово. Азот."
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
		db.actor:give_info_portion("take_message_azot")
	end
	
	if select_string=="kozl" then
		local text = "Стрелок, данные чёрного ящика полностью расшифрованы. Профессор Герман ожидает тебя в нашем бункере. Техник Козлов."
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
		db.actor:give_info_portion("take_kozlov_message")
	end
	
	if select_string=="kran1" then
		local text = "Джо: Стрелок, рядом с тобой какая-то дрянь атакует группу наших ребят. Без помощи им крышка."
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
	 local snd_obj = xr_sound.get_safe_sound_object([[characters_voice\scenario\zaton\jo_message]])
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		db.actor:give_info_portion("jo_quest_1")
	end
	
	if select_string=="gpis" then
		if level.name()=="jupiter" and has_alife_info("bul_first_dialog") and (not has_alife_info("bul_first_dialog_jup")) then
			local sobj = alife():object("jup_gausspistol")
			if sobj then
				local obj = level.object_by_id(sobj.id)
				if obj then
					spawn_item_in_inven("wpn_gungauss", obj)
					for ammo=1,30 do
						spawn_item_in_inven("ammo_super_gauss", obj)
					end
				end
			end
			db.actor:give_info_portion("bul_first_dialog_jup")
		end
	end
	
-- Начало алгоритма выброса --
	
-- 1. Настало время выброса.
	if select_string=="bl1" then
		if ogsm_surge then
			if not indoor_levels[level.name()] then
				if sleep_manager.is_sleep_active() then sleep_manager.stopper() end
				start_timer("bl2",1)
			else
				g_start_timer("bl1",0,1,0)
			end
		else
			g_start_timer("bl1",0,10,0)
		end
	end

-- 11. 1 Сообщение о приближении выброса

	if select_string=="bl2" then
		db.Flag2 = 2
		local text = "Приближение выброса"
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
		local snd_obj = xr_sound.get_safe_sound_object([[blowout\blowout_message_1]])
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		g_start_timer("bl21",0,0,15)
	end

-- 12. 2 Сообщение о приближении выброса

	if select_string=="bl21" then
		del_variable("bl2")
		local text = "Приближение выброса"
		news_manager.send_tip(db.actor, text, nil, nil, 30000)
		local snd_obj = xr_sound.get_safe_sound_object([[blowout\blowout_message_2]])
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		g_start_timer("bl22",0,0,3)
	end

-- 2. Сирена, первые визуальные признаки выброса
	if select_string=="bl22" then
		del_variable("bl21")
		db.Flag2 = 1
		save_variable("blt", 1)
		level.set_weather("stancia")
		wfx1 = "p_surge_day_"..tostring(level.get_time_hours())
		level.set_weather_fx(wfx1)
		level.add_pp_effector("vibros_p.ppe", 1974, false)
		local snd_obj = xr_sound.get_safe_sound_object([[anomaly\dezodor]])
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		g_start_timer("bl3",0,0,8)
	end

-- 3. Проигрываем промежуточные эффекты
	if select_string=="bl3" then
		del_variable("bl22")
		level.set_weather("stancia")
		level.set_weather_fx(wfx1)
		g_start_timer("bl4",0,0,5)
	end

-- 4. Спустя 5 минут затишья начинаем выброс
	if select_string=="bl4" then
		del_variable("bl3")
		uzi_artefacts.del_arts()
		xr_sound.set_actor_sound("")
		level.set_weather("stancia")
		local snd_obj = xr_sound.get_safe_sound_object([[ambient\earthquake]])
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		level.add_cam_effector("camera_effects\\earthquake.anm", 1974, true, "")
		wfx2 = "surge_day_"..tostring(level.get_time_hours())
		level.set_weather_fx(wfx2)
		level.add_pp_effector ("vibros.ppe", 1974, false)
		local snd_obj = xr_sound.get_safe_sound_object([[anomaly\blowout]])
		snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		ogsm_surge.play_sounds()
		g_start_timer("bl5",0,0,4)
	end

-- 5. Начинаем расколбас
	if select_string=="bl5" then
		del_variable("bl4")
		save_variable("blt", 2)
		level.remove_cam_effector(1974)
		db.Dead2 = 1
		if db.FlagEsc == 0 then
			local snd_obj = xr_sound.get_safe_sound_object([[actor\pain_3]])
			snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
			level.add_cam_effector("camera_effects\\head_shot.anm", 1975, false, "")
			ogsm_surge.g_R_Vibros:Run()
		end
		g_start_timer("bl6",0,0,5)
	end


-- 6. Выброс близится к концу
	if select_string=="bl6" then
		del_variable("bl5")
		level.set_weather_fx(wfx1)
		g_start_timer("bl7",0,0,5)
	end

-- 7. Завершаем выброс, устанавливаем время следующего
	if select_string=="bl7" then
		del_variable("bl6")
		ogsm_surge.g_R_Vibros:Stop()
		if db.FlagEsc == 0 then
			level.add_cam_effector("camera_effects\\shell_shock.anm", 1974, false, "")
			local snd_obj = xr_sound.get_safe_sound_object([[actor\breath_1]])
			snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		end
		level.add_pp_effector ("teleport.ppe", 2009, false)
		local snd_obj2 = xr_sound.get_safe_sound_object([[ambient\earthquake]])
		snd_obj2:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
		if has_alife_info("freeplay") and (level.name()=="l11_pripyat" or level.name()=="l10_radar") then
			level.set_weather("default")
		else
			level.set_weather(wthr)
		end
		del_variable("blt")
		g_start_timer("bl1",0, vars.t_surge+math.random(-4,4), 0)
		--ogsm_anomaly.add_anom()
--		ogsm_surge.spawn_arts()
		ogsm_respawn.level_spawn()
		if ogsm_psyzones then ogsm_psyzones.spawn_psy() end
		db.Dead2 = 0
		db.Flag2 = 0
		if not has_alife_info("first_blowout") then db.actor:give_info_portion("first_blowout") end
		uzi_monsters_respawn.resp_monsters()
		uzi_artefacts.spawn_arts()
		elseif db.Flag2 == 0 then
		del_variable("bl7")
	end


-- Конец алгоритма выброса --


	if select_string=="vdk" then
		ogsm_quests.use_vodka(params_string)
	end

	if select_string=="hrm" then
		ogsm_quests.use_harmonica(params_string)
	end

	if select_string=="rad" then
		ogsm_quests.use_radio(params_string)
	end

	if select_string=="ruk" then
		ogsm_quests.use_rukzak(params_string)
	end

	if select_string=="gss" then
		ogsm_quests.use_gps(params_string)
	end

	if select_string=="grb" then
		ogsm_quests.use_grib(params_string)
	end

	if select_string=="kit" then
		repair.use_kit(params_string)
	end

	if select_string=="spw" then
		if params_string == "rad" then spawn_item_in_inv("hand_radio_f")
		elseif params_string == "hrm" then spawn_item_in_inv("harmonica_f") end
	end

	if select_string=="scr" then
		ogsm_quests.spawn_fn2000()
		db.actor:give_info_portion("secret_talk")
	end

	if select_string=="fpl" then
		level_tasks.set_task_state(task.completed, "sar_warlab", 0)
		level_tasks.set_task_state(task.completed, "sar_warlab", 1)
	end

	if select_string=="oso" then
		level.add_pp_effector("deadcity_wake.ppe", 2008, false)
		local point = patrol("mon_jump_aes2_walk")
		local look = patrol("mon_jump_aes2_look")
		db.actor:set_actor_position(point:point(0))
		local dir = look:point(0):sub(point:point(0))
		db.actor:set_actor_direction(-dir:getH())
	end

	if select_string=="vd1" then
		local p = particles_object("anomaly2\\teleport_out_00")
		p:play_at_pos(params_string)
		local s = sound_object("anomaly\\teleport_incoming")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		start_timer("vd2", 2)
	end

	if select_string=="vd2" then
		level.add_pp_effector("teleport.ppe", 2009, false)
		local s = sound_object("anomaly\\teleport_work_2")
		s:play_at_pos(db.actor, vector():set(0, 0, 0), 0, sound_object.s2d)
		db.actor:give_info_portion("pri_trader_vanish")
		start_timer("vd3", 2)
	end

	if select_string=="vd3" then
		local s = sound_object("x18_laugh")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		level.enable_input()
		db.actor:restore_weapon()
	end

--  Обработка наказаний при увеличении жажды, довёл до ума kenguru

-- Если отработал мгновенный нулевой счётчик - выдаётся следующий порог, и начинается отсчёт следующего таймера жажды
	if select_string=="water0" then
		if (not has_alife_info("start_water_1")) and (not has_alife_info("start_water_2")) and (not has_alife_info("start_water_3")) then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			get_hud():AddCustomStatic("water_green", true)
			db.actor:give_info_portion("start_water_1")
			g_start_timer("water2",0, 1, 0)
		elseif has_alife_info("start_water_1") and (not has_alife_info("start_water_2")) and (not has_alife_info("start_water_3")) then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			get_hud():RemoveCustomStatic("water_green")
			get_hud():AddCustomStatic("water_yellow", true)
			db.actor:give_info_portion("start_water_2")
			g_start_timer("water3",0, 1, 0)
		elseif has_alife_info("start_water_1") and has_alife_info("start_water_2") and (not has_alife_info("start_water_3")) then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			get_hud():RemoveCustomStatic("water_yellow")
			get_hud():AddCustomStatic("water_red", true)
			db.actor:give_info_portion("start_water_3")
			g_start_timer("water4",0, 1, 0)
		elseif has_alife_info("start_water_1") and has_alife_info("start_water_2") and has_alife_info("start_water_3") then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			db.actor.health = -0.05
			g_start_timer("water5",0, 0.6, 0)
		end
	end
-- Если отработал первый счётчик и нет выданных порогов жажды - выдаётся первый порог, и начинается отсчёт таймера второй жажды
	if select_string=="water1" then
		if (not has_alife_info("start_water_1")) and (not has_alife_info("start_water_2")) and (not has_alife_info("start_water_3")) then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			get_hud():AddCustomStatic("water_green", true)
			db.actor:give_info_portion("start_water_1")
			g_start_timer("water2",0, 1, 0)
		end
	end
-- Если есть первый порог и отработал второй счётчик - выдаётся второй порог, и начинается отсчёт таймера третьей жажды
	if select_string=="water2" then
		if has_alife_info("start_water_1") and (not has_alife_info("start_water_2")) and (not has_alife_info("start_water_3")) then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			get_hud():RemoveCustomStatic("water_green")
			get_hud():AddCustomStatic("water_yellow", true)
			db.actor:give_info_portion("start_water_2")
			g_start_timer("water3",0, 1, 0)
		end
	end
-- Если есть второй порог и отработал третий счётчик - выдаётся третий порог, и начинается отсчёт таймера четвёртой жажды
	if select_string=="water3" then
		if has_alife_info("start_water_1") and has_alife_info("start_water_2") and (not has_alife_info("start_water_3")) then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			get_hud():RemoveCustomStatic("water_yellow")
			get_hud():AddCustomStatic("water_red", true)
			db.actor:give_info_portion("start_water_3")
			g_start_timer("water4",0, 1, 0)
		end
	end
-- Если есть третий порог и отработал четвёртый счётчик - здоровье ГГ минус 5%
	if select_string=="water4" then
		if has_alife_info("start_water_1") and has_alife_info("start_water_2") and has_alife_info("start_water_3") then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			db.actor.health = -0.05
			g_start_timer("water5",0, 0.6, 0)
		end
	end
-- Если отработал и пятый счётчик - здоровье продолжит убывать каждый час по 5%
	if select_string=="water5" then
		if has_alife_info("start_water_1") and has_alife_info("start_water_2") and has_alife_info("start_water_3") then
			del_variable("water5")
			del_variable("water4")
			del_variable("water3")
			del_variable("water2")
			del_variable("water1")
			del_variable("water0")
			
			db.actor.health = -0.05
			g_start_timer("water5",0, 0.6, 0)
		end
	end
	
-- Если костёр прогорел
	if select_string=="koster" then
		local id, obj
		
		for id=0, 65535 do
			obj = level.object_by_id(id)
			
			if obj ~= nil and obj:section() == "koster" then
				if obj:position():distance_to(db.actor:position()) > 50 then
					alife():release(alife():object(id), true)
				end
			end
			
			if obj ~= nil and obj:section() == "light_koster" then
				alife():release(alife():object(id), true)
			end
		end
		
		del_variable("koster")
		
		g_start_timer("koster",0, 0, 30)
	end
end


-- Спавним объекты на карту
-- Для спавна неписей смотрим config\creatures\spawn_sections.ltx
-- Там написаны имена секций для разных типов неписей
function spawn_item(spawn_item, pos)
	return alife():create(spawn_item, pos, 1, db.actor:game_vertex_id())
end


-- Спавним объекты в инвентарь
function spawn_item_in_inv(spawn_item,npc)
	if npc==nil then
		npc=db.actor
	end
	return alife():create(spawn_item,
		npc:position(),
		npc:level_vertex_id(),
		npc:game_vertex_id(),
		npc:id())
end


-- Спавним патроны в инвентарь
function spawn_ammo_in_inv(spawn_item,number,npc)
	if npc==nil then
		npc=db.actor
	end
	if number > 0 then
		return se_respawn.create_ammo(spawn_item,
				npc:position(),
				npc:level_vertex_id(),
				npc:game_vertex_id(),
				npc:id(),
				number)
	end
end


-- Удаляем объект из игры
function remove_item(remove_item)
	if remove_item~=nil then
		alife():release(alife():object(remove_item:id()), true)
		return true
	end
	return false
end


-- Выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
	if item~=nil then
		npc:mark_item_dropped(item)
	end
end


-- Убиваем непися
function make_suicide(npc)
	npc:kill(npc)
end


-- Узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
	local rel = obj:relation(target)
	local relation
	if rel==game_object.neutral then
		relation="neutral"
	elseif rel==game_object.friend then
		relation="friend"
	elseif rel==game_object.enemy then
		relation="enemy"
	else
		return false
	end
	return relation
end


-- Задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
	local rel
	if relation=="neutral" then
		rel=game_object.neutral
	elseif relation=="friend" then
		rel=game_object.friend
	elseif relation=="enemy" then
		rel=game_object.enemy
	else
		return false
	end
	obj:set_relation(rel,target)
	return true
end


-- Узнаем группировку непися, применимо к ГГ
function get_npc_community(npc)
	return npc:community()
end


-- Выставляем группировку непися, можно ГГ
function set_npc_community(npc,community_string)
	--значения для community_string можно узнать в config\creatures\game_relations.ltx
	return npc:set_character_community(community_string, 0, 0)
end


-- Удаляем предмет из инвентаря
function remove_item_from_inventory_by_name(remove_item_name,npc)
	return remove_item_from_inventory(npc:object(remove_item_name),npc)
end

function remove_item_from_inventory(remove_item,npc)
	if npc==nil then npc=db.actor end
	
	if remove_item~=nil then
		npc:mark_item_dropped(remove_item)
		alife():release(alife():object(remove_item:id()), true)
		return true
	end
	
	return false
end


-- Создаем "ожидатели" для неписей нужно для корректной работы с объектами, созданными внутри скрипта
function create_waiter_for_npc(npc,select_string)
	npc_spawner[npc.id]=select_string
end


-- Очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc)
	npc:iterate_inventory(__del_item, npc)
end

function __del_item(npc, item)
	local section = item:section()
	
	if section == "bolt" or section == "device_torch" then
		return
	end
	
	npc:mark_item_dropped(item)
	alife():release(alife():object(item:id()), true)
end


-- Проверка, запущена ли игра
function check_game()
	if level.present() and (db.actor ~= nil) and db.actor:alive() then
		return true
	end
	return false
end

-- Записываем переменную
function save_variable(variable_name, value)
	xr_logic.pstor_store(db.actor, variable_name, value)
end

-- Загружаем переменную
function load_variable(variable_name, value_if_not_found)
	return xr_logic.pstor_retrieve(db.actor, variable_name, value_if_not_found)
end

-- Удаляем переменную
function del_variable(variable_name)
	if db.storage[db.actor:id()].pstor[variable_name] then
		db.storage[db.actor:id()].pstor[variable_name] = nil
	end
end


-- Определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2)
	local pos=npc:position()
	if is_point_inside_interval(pos.x,p1.x,p2.x) and
		is_point_inside_interval(pos.y,p1.y,p2.y) and
		is_point_inside_interval(pos.z,p1.z,p2.z) then
		return true
	else
		return false
	end
end
function is_point_inside_interval(x,p1,p2)
	if p1>p2 then
		p1,p2 = p2,p1
	end

	if x>p1 and x<p2 then
		return true
	else
		return false
	end
end


-- Получаем инвентарное название объекта
function get_inv_name(section)
	return system_ini():r_string(section,"inv_name")
end

-- Колбэк на потерю предмета из инвентаря ГГ
function on_item_drop(obj)
	sleep_manager.check_sleep_item(obj)
	ogsm_quests.check_use_harmonica(obj)
	ogsm_quests.check_use_radio(obj)
	ogsm_quests.check_use_rukzak(obj)
	ogsm_quests.check_use_gps(obj)
	ogsm_quests.check_use_grib(obj)
end

-- Колбэк на апдейт ГГ
function on_actor_update(obj)
	-- Очищаем уровни от трупов во фриплее
	ogsm_debug.clean_level()

	-- Обновление арены
	aem_manager.get_aem():update()

	-- Обновление таймеров
	if not timer_trigger then
		timer_trigger=game.time()
	end
	if timer_trigger<=game.time() then
		timer_trigger=game.time()+5000
		check_timers()
	end
	
	if has_alife_info("ui_talk_hide") then
		 check_armor()
	end
	-- Багфикс радара
	ogsm_debug.check_radar_off()
	
	-- Обновление шкалы радиации при использовании бинокля
	ogsm_debug.check_binoc()
	
	-- Обновление статистики
	-- ogsm_debug.hud_stats()
	
	-- Обновление менеджера выброса и аномалий
	if ogsm_surge then
		ogsm_surge.update_surge()
		--ogsm_anomaly.anom_update()
	end
	
	-- Проверка, пьян ли актор
	ogsm_quests.check_drunk()
	
	-- Проверка, ранен ли актор
	ogsm_quests.wounded_pp()
	
	-- Багфикс таймеров
	local d = game.time()
	if d >= 200000 then
		k = 0
	end
	if k == 0 then
		if d < 200000 then
			ogsm_debug.clean_pstor()
			timer_trigger=game.time()
			check_timers()
			k = 1
			get_console():execute("AMK_timers_restart!")
		end
	end
end


-- Загружаем все переменные, которые нужно, вызывается загрузке игры автоматически
function on_game_load()

	-- Восстанавливаем солнце
	wthr = level.get_weather()
	level.set_weather("ogsm",true)
	game.start_tutorial("restore_sun")

	-- Создаем хранилище актора
	if db.storage[db.actor:id()].pstor == nil then
		db.storage[db.actor:id()].pstor = {}
	end

	-- Первый запуск мода
	if load_variable("frn",true) then
		g_start_timer("slp",0,0,6)
		g_start_timer("bl1",0, 9+math.random(-1,1), 0)
		g_start_timer("rsp",0, 5+math.random(-1,1), 0)
		spawn_item_in_inv("matras")
		ogsm_respawn.first_run()
		save_variable("frn",false)
		
	end
	
	-- Проверяем сонность
	sleep_manager.test_sleep_pp()

	-- Получаем список всех монстров и укрытий
	ogsm_respawn.get_level_mobs()

	-- Спавним, если надо, пси-зоны
	if ogsm_psyzones then ogsm_psyzones.spawn_on_load() end

	-- Отмечаем на карте новые точки перехода
	ogsm_freeplay.mark_lc()
	
	

end


-- Парсинг ини-файла в массив
function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end
function trim (s)
	return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end


-- Туториал на пси-воздействие
function on_my_psy()
	if not has_alife_info("encyclopedy_tutorial_psy") then
		game.start_tutorial("part_7_psy")
		db.actor:give_info_portion("encyclopedy_tutorial_psy")
	end
end


-- Восстановление солнца и погоды, вызывается из туториала
function restore_sun()

if load_variable("blt",0) == 1 then
	level.set_weather("stancia")
	db.Flag2 = 1
elseif load_variable("blt",0) == 2 then
	level.set_weather("stancia")
	db.Flag2 = 1
	db.Dead2 = 1
else
	if has_alife_info("freeplay") and (level.name()=="l12_stancia" or level.name()=="l12_stancia_2" or level.name()=="l11_pripyat" or level.name()=="l10_radar") then
		level.set_weather("default")
	else
		level.set_weather(wthr)
	end
end

end

function get_invbox_data(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local t={}
	amk.parse_object_packet(t,stpk,uppk,size)
	amk.parse_visual_packet(t,stpk,uppk,size)
	return t
end

function set_invbox_data(t,sobj)
	local stpk=net_packet()
	local uppk=net_packet()

	amk.fill_object_packet(t,stpk,uppk)
	amk.fill_visual_packet(t,stpk,uppk)

	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
end

function parse_object_packet(ret,stpk,updpk)
	ret.gvid=stpk:r_u16()
	ret.obf32u1=stpk:r_float()
	ret.obs32u2=stpk:r_s32()
	ret.lvid=stpk:r_s32()
	ret.oflags=stpk:r_s32()
	ret.custom=stpk:r_stringZ()
	ret.sid=stpk:r_s32()
	ret.obs32u3=stpk:r_s32()
	return ret
end

function parse_visual_packet(ret,stpk,updpk)
	ret.visual=stpk:r_stringZ()
	ret.vsu8u1=stpk:r_u8()
	return ret
end

function fill_object_packet(ret,stpk,updpk)
	stpk:w_u16(ret.gvid)
	stpk:w_float(ret.obf32u1)
	stpk:w_s32(ret.obs32u2)
	stpk:w_s32(ret.lvid)
	stpk:w_s32(ret.oflags)
	stpk:w_stringZ(ret.custom)
	stpk:w_s32(ret.sid)
	stpk:w_s32(ret.obs32u3)
end

function fill_visual_packet(ret,stpk,updpk)
	stpk:w_stringZ(ret.visual)
	stpk:w_u8(ret.vsu8u1)
end

function read_monster_params(sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	sobj:STATE_Write(stpk)
	sobj:UPDATE_Write(uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	stpk:r_seek(0)
	uppk:r_seek(0)
	local tbl=amk.parse_se_monster_packet({},stpk,uppk,size)
	return tbl
end

function write_monster_params(tbl,sobj)
	local stpk=net_packet()
	local uppk=net_packet()
	amk.fill_se_monster_packet(tbl,stpk,uppk)
	local size=stpk:w_tell()
	local size1=uppk:w_tell()
	-- amk.mylog("wsp "..size.." "..size1)
	stpk:r_seek(0)
	uppk:r_seek(0)
	sobj:STATE_Read(stpk,size)
	sobj:UPDATE_Read(uppk)
	-- local npc=level.object_by_id(sobj.id)
	-- if npc then
	-- amk.convert_npc[sobj.id]=true
	-- switch_offline(npc)
	-- end
end

function parse_se_monster_packet(ret,stpk,updpk,size)
	parse_monster_packet(ret,stpk,updpk,size)
	parse_skeleton_packet(ret,stpk,updpk,size)
	ret.spec_obj_id=stpk:r_u16()
	ret.job_online=stpk:r_u8()
	if ret.job_online>3 then
		ret.state=true
		ret.job_online=ret.job_online-4
	else
		ret.state=false
	end
	if ret.job_online==3 then
	ret.job_online_condlist=stpk:r_stringZ()
	end
	ret.was_in_smtr=stpk:r_u8()
	ret.stunk1={}
	for i=stpk:r_tell(),size-1,1 do
	table.insert(ret.stunk1,stpk:r_u8())
	end
	return ret
end

function fill_se_monster_packet(ret,stpk,updpk)
	fill_monster_packet(ret,stpk,updpk)
	fill_skeleton_packet(ret,stpk,updpk)
	stpk:w_u16(ret.spec_obj_id)
	local st=0
	if ret.state then
		st=4
	end
	stpk:w_u8(ret.job_online+st)
	if ret.job_online==3 then
	stpk:w_stringZ(ret.job_online_condlist)
	end
	stpk:w_u8(ret.was_in_smtr)
	for i,v in ipairs(ret.stunk1) do
	stpk:w_u8(v)
	end
end

function parse_monster_packet(ret,stpk,updpk)
	parse_creature_packet(ret,stpk,updpk)
	ret.baseoutr=stpk:r_stringZ()
	ret.baseinr=stpk:r_stringZ()
	ret.smtrid=stpk:r_u16()
	ret.smtrtaskactive=stpk:r_u8()

	ret.updu16u1=updpk:r_u16()
	ret.updu16u2=updpk:r_u16()
	ret.upds32u3=updpk:r_s32()
	ret.upds32u4=updpk:r_s32()
	return ret
end

function fill_monster_packet(ret,stpk,updpk)
	fill_creature_packet(ret,stpk,updpk)
	stpk:w_stringZ(ret.baseoutr)
	stpk:w_stringZ(ret.baseinr)
	stpk:w_u16(ret.smtrid)
	stpk:w_u8(ret.smtrtaskactive)

	updpk:w_u16(ret.updu16u1)
	updpk:w_u16(ret.updu16u2)
	updpk:w_s32(ret.upds32u3)
	updpk:w_s32(ret.upds32u4)
end

function parse_skeleton_packet(ret,stpk,updpk)
	ret.skeleton=stpk:r_stringZ()
	ret.skeleton_flags=stpk:r_u8()
	ret.source_id=stpk:r_u16()

-- ret.updsku8u1=updpk:r_u8()
	return ret
end

function fill_skeleton_packet(ret,stpk,updpk)
	stpk:w_stringZ(ret.skeleton)
	stpk:w_u8(ret.skeleton_flags)
	stpk:w_u16(ret.source_id)

-- updpk:w_u8(ret.updsku8u1)
end

function parse_creature_packet(ret,stpk,updpk)
	parse_dynamic_object_visual(ret,stpk,updpk)
	ret.team=stpk:r_u8()
	ret.squad=stpk:r_u8()
	ret.group=stpk:r_u8()
	ret.health=stpk:r_float()
	ret.crvu32u16u1=readvu32u16(stpk)
	ret.crvu32u16u2=readvu32u16(stpk)
	ret.killerid=stpk:r_u16()
	ret.game_death_time=readvu8u8(stpk)

	ret.updhealth=updpk:r_float()
	ret.upds32u1=updpk:r_s32()
	ret.updu8u2=updpk:r_u8()
	ret.updpos={} -- или поставить вектор? ладно потом
	ret.updpos.x=updpk:r_float()
	ret.updpos.y=updpk:r_float()
	ret.updpos.z=updpk:r_float()
	ret.updmodel=updpk:r_float()
	ret.upddir={}
	ret.upddir.x=updpk:r_float()
	ret.upddir.y=updpk:r_float()
	ret.upddir.z=updpk:r_float()
	ret.updteam=updpk:r_u8()
	ret.updsquad=updpk:r_u8()
	ret.updgroup=updpk:r_u8()
	return ret
end

function fill_creature_packet(ret,stpk,updpk)
	fill_dynamic_object_visual(ret,stpk,updpk)
	stpk:w_u8(ret.team)
	stpk:w_u8(ret.squad)
	stpk:w_u8(ret.group)
	stpk:w_float(ret.health)
	writevu32u16(stpk,ret.crvu32u16u1)
	writevu32u16(stpk,ret.crvu32u16u2)
	stpk:w_u16(ret.killerid)
	writevu8u8(stpk,ret.game_death_time)

	updpk:w_float(ret.updhealth)
	updpk:w_s32(ret.upds32u1)
	updpk:w_u8(ret.updu8u2)
	updpk:w_float(ret.updpos.x)
	updpk:w_float(ret.updpos.y)
	updpk:w_float(ret.updpos.z)
	updpk:w_float(ret.updmodel)
	updpk:w_float(ret.upddir.x)
	updpk:w_float(ret.upddir.y)
	updpk:w_float(ret.upddir.z)
	updpk:w_u8(ret.updteam)
	updpk:w_u8(ret.updsquad)
	updpk:w_u8(ret.updgroup)
end

function parse_dynamic_object_visual(ret,stpk,updpk)
	parse_object_packet(ret,stpk,updpk)
	parse_visual_packet(ret,stpk,updpk)
	return ret
end

function fill_dynamic_object_visual(ret,stpk,updpk)
	fill_object_packet(ret,stpk,updpk)
	fill_visual_packet(ret,stpk,updpk)
end

function readvu32u16(packet)
	local v={}
	local len=packet:r_s32()
	for i=1,len,1 do
	table.insert(v,packet:r_u16())
	end
	return v
end

function readvu8u8(packet)
	local v={}
	local len=8
	for i=1,len,1 do
	table.insert(v,packet:r_u8())
	end
	return v
end

function writevu32u16(pk,v)
	local len=#v
	pk:w_s32(len)
	for i=1,len,1 do
	pk:w_u16(v[i])
	end
end

function writevu8u8(pk,v)
	local len=8 --table.getn(v)
	--pk:w_u8(len)
	for i=1,len,1 do
	pk:w_u8(v[i])
	end
end

function spawn_item_in_inven(spawn_item,npc)
	if not npc then
		npc = db.actor
	end
	local item = alife():create(spawn_item,
		npc:position(),
		npc:level_vertex_id(),
		npc:game_vertex_id(),
		npc:id())
	
	if npc:id() ~= db.actor:id() then
		-- Фикс пропадания доспавненного предмета при сейв/лоаде
		level.client_spawn_manager():add(item.id, -1, fix_spawn_item_in_inven, npc) -- Калбек на выход item в онлайн
	end

	return item
end

function fix_spawn_item_in_inven(npc, id, item)
	npc:transfer_item(item, npc)
end

function spawn_item_in_invenn(spawn_item,npc)
	if not npc then
		npc = db.actor
	end
	local item = alife():create(spawn_item,
		npc:position(),
		npc:level_vertex_id(),
		npc:game_vertex_id(),
		npc:id())

	if npc:id() ~= db.actor:id() then
		-- Фикс пропадания доспавненного предмета при сейв/лоаде
		level.client_spawn_manager():add(item.id, -1, fix_spawn_item_in_invenn, npc) -- Калбек на выход item в онлайн
	end

	return item
end

function fix_spawn_item_in_invenn(npc, id, item)
	npc:transfer_item(item, npc)
end

local last_armor_id, last_condition = 0, 0
function is_repaired(armor, condition)
	last_armor_id = armor:id()
	last_condition = condition
end

function check_armor()
	local armor = db.actor:item_in_slot(6)
	if not armor then
		last_armor_id = 0
		return
	end

	if armor:id() ~= last_armor_id then
		last_armor_id = armor:id()
		last_condition = armor:condition()
		return
	end

	if last_condition < armor:condition() then
		armor:set_condition(last_condition)
	else
		last_condition = armor:condition()
	end
end

------------------- Библиотека служебных скриптов для OGSM 2.x ----------------

---------------------- Copyright 2007-2008 xStream & DEXXX --------------------

--[[

If you're going to use the whole of this script or its parts in your own creative
developments for the S.T.A.L.K.E.R. game, please don't become such a goddamn
motherfucker like the notorious author of the ABC Mod - Carbrobro. Leave the
copyrights, note the real author(s) and don't claim others' ideas and their
realization to be your own ones. It's just simple Modmakers' Ethics. Thank you!

Если вы собираетесь использовать данный скрипт целиком или частично в своих
разработках по игре S.T.A.L.K.E.R., пожалуйста не опускайтесь до уровня печально
известного автора ABC мода - Carbrobro. Не удаляйте копирайты, указывайте настоящего
автора(ов) и не выдавайте чужие идеи и их реализацию за свои. Ведь это элементарная
этика модостроителей! Спасибо за понимание.

]]--